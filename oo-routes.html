<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../iron-selector/iron-selectable.html">

<dom-module id="oo-routes">

  <script>
    // Declare in local function scope to avoid bleeding variables into global `window`.
    (function () {
      class OoRoutes extends Polymer.mixinBehaviors(
        [Polymer.IronSelectableBehavior], Polymer.Element) {

        static get is() {
          return "oo-routes"
        }

        static get properties() {
          return {
            route: {
              type: String,
              notify: true,
              reflectToAttribute: true,
              observer: "_onItemsChanged"
            },

            selected: {
              type: Object,
              notify: true,
              reflectToAttribute: true,
              value: null
            },

            params: {
              type: String,
              notify: true,
              value: () => { return {} }
            }
          }
        }

        ready() {
          super.ready()
          this.addEventListener("iron-items-changed", this._onItemsChanged)
        }

        _onItemsChanged() {
          this._pathToRoute(this.route)
        }

        _pathToRoute(route) {
          let selectedIndex = null
          let selected = null
          let params = null

          for (const itemIndex in this.items) {
            const routeItem = this.items[itemIndex]
            const routeParams = this._matchRoute(route, routeItem)
            if (routeParams !== NO_MATCH) {
              selectedIndex = itemIndex
              selected = this._indexToValue(itemIndex) || null
              params = routeParams
              break
            }
          }

          // this ensures `selected` is either a value or null (not undefined), and
          // `params` is an object (not an array when we have positional parameters).
          this.setProperties({
            selected: selected || null,
            params: Object.assign({}, params)
          })
        }

        _pathForRoute(name, params) {
          let routePattern = null

          for (const itemIndex in this.items) {
            const routeItem = this.items[itemIndex]
            const routeName = this._indexToValue(itemIndex)
            if (routeName === name) {
              routePattern = routeItem.pattern
            }
          }

          if (routePattern) {
            routePattern = this._toLocationPath(routePattern, params)
          }

          return routePattern
        }

        /**
         * from location.route.path.
         */
        _fromLocationPath(routePattern, locationPath, mapQueryToParams=true) {
          const { path, queryParams } = this._parseLocationPath(locationPath)

          const routeParams = matchRoutePathPattern(path, routePattern)
          if (routeParams === NO_MATCH) { return NO_MATCH }

          if (mapQueryToParams) {
            Object.assign(routeParams, queryParams)
          }
          return routeParams
        }

        _toLocationPath(routePattern, routeParams, mapParamsToQuery=true) {
          return buildRoutePathPattern(routePattern, routeParams, mapParamsToQuery)
        }

        _fromLocationPathRegexp(routePattern, locationPath, mapQueryToParams=true) {
          const { path, queryParams } = this._parseLocationPath(locationPath)

          const routeParams = matchRoutePathRegexp(path, routePattern)
          if (routeParams === NO_MATCH) { return NO_MATCH }

          if (mapQueryToParams) {
            Object.assign(routeParams, queryParams)
          }
          return routeParams
        }

        _toLocationPathRegexp(routePattern, routeParams, mapParamsToQuery=true) {
          return buildRoutePathRegexp(routePattern, routeParams, mapParamsToQuery)
        }

        _matchRoute(route, routeItem) {
          const { path, queryParams } = this._parseLocationPath(route)

          const params = routeItem.useRegexp
            ? matchRoutePathRegexp(path, routeItem.pattern)
            : matchRoutePathPattern(path, routeItem.pattern)
          if (params === NO_MATCH) { return NO_MATCH }

          if (routeItem.mapQueryToParams) {
            Object.assign(params, queryParams)
          }
          return params
        }

        _parseLocationPath(locationPath) {
          return parseLocationPath(locationPath)
        }
      }

      const NO_MATCH = null

      const T_COLON = ":"
      const T_SLASH = "/"
      const T_AMPERSAND = "&"
      const T_QUESTION_MARK = "?"
      const T_EQUALS_SIGN = "="

      function matchRoutePathRegexp(path, pattern) {
        const regexp = new RegExp(pattern)
        const match = regexp.exec(path)

        // Did match regular expression.
        if (match) {
          return Object.assign({}, match.slice(1))
        }

        // Did not match.
        return NO_MATCH
      }

      function buildRoutePathRegexp(pattern, params, withQueryParams=true) {
        const regexp = new RegExp("(\\(.*?\\))", "g")
        const match = regexp.exec(pattern)

        // Did match regular expression.
        let result = pattern
        if (match) {
          let groupIndex = 0
          result = pattern.replace(regexp, () => {
            const param = params[groupIndex]
            delete params[groupIndex]
            groupIndex += 1
            return param
          })
        }

        // Did not match.
        let query = ""
        if (withQueryParams) {
          let index = 0
          for (const key in params) {
            const value = params[key]
            const sep = index === 0 ? T_QUESTION_MARK : T_AMPERSAND
            query = query + sep + key + T_EQUALS_SIGN + value
            index += 1
          }
        }

        return result + query
      }

      function matchRoutePathPattern(path, pattern) {
        const pathElements = path.split(T_SLASH)
        const patternElements = pattern.split(T_SLASH)
        const params = {}

        // Match all path pattern elements.
        for (index in patternElements) {
          const pathElement = pathElements[index]
          const patternElement = patternElements[index]

          // Is direct match.
          if (pathElement === patternElement) {
            continue
          }

          // Is wildcard parameter.
          if (patternElement.startsWith(T_COLON)) {
            const param = patternElement.slice(1)
            params[param] = pathElement
            continue
          }

          // Did not match.
          return NO_MATCH
        }

        // All elements matched.
        return params
      }

      function buildRoutePathPattern(pattern, params, withQueryParams=true) {
        const queryParams = {}
        for (const key in params) {
          const value = params[key]
          if (pattern.includes(T_COLON + key)) {
            pattern = pattern.replace(T_COLON + key, value)
          }
          else {
            queryParams[key] = value
          }
        }

        let query = ""
        if (withQueryParams) {
          let index = 0
          for (const key in queryParams) {
            const value = queryParams[key]
            const sep = index === 0 ? T_QUESTION_MARK : T_AMPERSAND
            query = query + sep + key + T_EQUALS_SIGN + value
            index += 1
          }
        }

        return pattern + query
      }

      function parseLocationPath(locationPath) {
        // path and query.
        const [path, pathRest] = locationPath.split(T_QUESTION_MARK, 2)
        const query = pathRest || ""

        // path segments.
        const pathSegments = path.split(T_SLASH)

        // query params.
        const queryParams = query.split(T_AMPERSAND)
          .filter(param => !isEmptyString(param))
          .map(param => (
            param.split(T_EQUALS_SIGN, 2)
          ))
          .reduce((result, [key, value]) => (
            result[key] = value || null, result
          ), {})

        return { path, query, pathSegments, queryParams }
      }

      function isEmptyString(value) {
        return value === ""
      }

      window.customElements.define(OoRoutes.is, OoRoutes)

    }())
  </script>

</dom-module>